
进程：
  想要使程序并发执行，存在间断性，失去封闭性，不可再现等问题，引入进程
  动态执行的应用程序，不仅有代码段，还有内存和文件io等运行资源。运行态、就绪态、阻塞态，线程间状态切换会自动保存上下文，使进程并发执行，进程间引入同步机制。执行副本，资源分配的最小单位。

使用场景: cpu密集型运算， 涉及到很多io阻塞等待

线程：

代码执行线，线程被cpu调度并发执行，cpu运行调度的基本单元。共享进程的运行资源，虚拟内存，文件列表等，线程间通信很方便。

协程:

同样有执行上下文的保存和恢复，用户程序通过函数调用的形式进行执行线的切换，不涉及执行上下文的切换



#### 线程安全

加锁的成本开销有多大，业务场景中访问的共享资源的方式，并发访问共享资源时的冲突概率

互斥访问（互斥锁）：互斥锁（队列排队等待），自旋锁（轮询尝试获取锁）
      互斥锁的代价：线程状态上下文切换 运行态-> 阻塞态，阻塞态-> 就绪态
      自旋锁上锁代价：占有锁线程的运行时间

乐观锁(无锁)：假设竞争不激烈，不断重试

![avatar](./java线程生命周期.jpg)


降低锁竞争：
- 设计成不可变类，threadlocal 多份变量
- 减小锁粒度，减少锁持有时间
- 读写锁分离

上下文切换: 时间片用完，虚拟机内存回收

线程池:
  线程太多: 内存占用，线程太多 时间花在上下文切换，影响吞吐率
线程自身
合理设置线程数量 线程池

threadlocal<ClassType> 每个线程t 有一个threadLocalMap
key=threadlocal weak reference; value 用完要remove 否则会发生内存泄漏

避免死锁：
    银行家算法



### **web 后台存取数据，通信**

#### 文件系统：
  ```
  连续存储 链式存储
  索引
  ```
日志文件系统

#### io 模型:
   同步：

      阻塞  等待从磁盘->page cache, page cache->内存 1线程对应1 io
      非阻塞 轮询page cache 中数据是否准备好，没有则直接返回。page cache -> 内存仍然是阻塞的

      io多路复用：1个线程轮询多个socket的情况，支持更高的并发量
         select, poll:
            将多个文件描述符从用户空间传入内核空间,
            内核轮询列表看是否有socket就绪，有则设置标记状态
            将fd列表从内核空间传入用户空间，
            用户遍历列表对可读可写的socket的读写数据处理
            差别: select用数组存储，poll用链表存储没有fd数量的限制
         epoll:
            由内核维护fd列表，红黑树，调用epoll_ctl添加删除fd
            epoll_wait 时，当有socket 可读可写时，通过回调添加到就绪链表，返回给用户空间
            边缘触发，水平触发：
               当socket就绪，用户不做处理，第二次不通知（边缘触发），
               所以一般配合非阻塞io处理，减少系统调用次数

   异步：异步是一种编程模型，它通过将耗时的操作转移到后台线程运行，从而减少对主业务的堵塞，所以我们说异步让速度变快了


#### tcp
   流量控制
   拥塞控制

   最大报文段 SMSS(sender Maximum Segment Size),  慢开始门限(ssthresh)

当cwnd < ssthresh 收到接收方确认后，cwnd指数增长

cwmd > ssthresh 收到接收方确认后，cwnd 线性增长 **拥塞避免**

超时未收到确认，判断 网络出现拥塞，ssthresh = cwmd / 2, cwnd = 1,执行慢开始

连续收到3个重复确认，立即重传 k **快重传**

只是个别报文段的丢失，快恢复，ssthresh = cwnd / 2, cwmd /= 2, 执行拥塞避免算法 **快恢复**

数据库三范式
    1范式 列的原子性，不可再分
    2范式 列依赖于主键，而不是依赖与主键的一部分
    3范式 不存在列对主键的传递依赖
    数据冗余，更新维护简单。


#### Mysql

- ACID特性

- 方便进行聚合范围查找，聚合、统计等操作

- 当数据规模变大时，查找性能变低


**存储**： 磁盘，B+树，支持索引查找，磁盘块读出

操作时间因素：**时间复杂度** + **数据规模**

当单表数据量很大时，查询性能很低  (减小表规模、将请求分发到多台服务器上 )

- 将历史数据归档到备份表
- 集群：主从复制，利用从数据库进行读写分离
- 缓存：缓存部分联表查询结果等
- 分库分表：减小数据规模

提高运算能力，集群，保持数据一致性，负载均衡


#### Redis:

-  基于内存的k-v数据库，数据结构，读写性能高
-  内存容量有限，对事务的支持差，不用于持久层

​    将mysql的数据 子集 缓存在redis中

#### redis mysql 数据一致性：不考虑进程执行中断

- 先更新缓存，再更新数据库
   a更新缓存 b更新缓存 ---> b更新数据库 a更新数据库
- 先更新数据库，再更新缓存
   a更新数据库 b更新数据库   --->  b更新缓存 a更新缓存

- 先删除缓存，再更新数据库
   a 删除缓存  ->  b读数据库更新缓存  ->  a 更新数据库
- 先更新数据库，再删除缓存
   b查找数据库 a更新数据库    --->  a删除缓存 b用旧值更新缓存 (这种发生概率比较低，因为更新数据库一般比查找耗时长，所以a删除缓存在后)

   问题: a 更新数据库，到删除缓存这段时间，b读到旧的缓存值(短暂不一致)

不能保证两个操作同时成功或失败

- 延时双删

   上述实践中大都可以保证相对一致性，若保证绝对一致性，要依靠事务保证操作更新同时成功或失败，出现问题则回滚，但**这与使用缓存提高性能的初衷相违背**，得不偿失。

缓存的命中率

cache aside: 旁路缓存模式
- 读：
​     缓存中有值，直接返回
​     缓存中无值，从数据库取值，更新缓存，返回
- 写
  更新数据库，删除缓存

read write through

write behind



replication 备份
sharding 分片


#### Java 内存模型：
   定义了不同的线程之间，通过哪些方式，在什么时候可以看见其他线程保存到共享变量中的值；以及在必要时，如何对共享变量的访问进行同步。这样的好处是屏蔽各种硬件平台和操作系统之间的内存访问差异，实现了 Java 并发程序真正的跨平台。定义程序中各种变量的访问规则

垃圾回收，边引用 边判别？

方法区主要是用来存放已被虚拟机加载的类相关信息，包括类信息、运行时常量池、字符串常量池。类信息又包括了类的版本、字段、方法、接口和父类等信息。

ZooKeeper 底层其实只提供了两个功能：① 管理（存储、读取）用户程序提交的数据；② 为用户程序提供数据节点监听服务


高可用
高性能： 响应时间，吞吐量、并发量
可伸缩
高可扩展

消息队列延迟时间
低延迟、高可靠。高吞吐



spring framework

classpathxmlApplicationContext 容器
构造方法
管理哪些对象
如何将管理的对象告知Ioc容器
如何获取Ioc容器
如何从容器中获取bean


servlet 有servlet容器创建，第一次被访问时，由容器创建
初始化
请求处理
服务终止



