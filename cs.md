
进程：
  正在执行的应用程序，不仅有代码段，还有内存和文件io等运行资源，执行副本，资源分配的最小单位
线程：
  代码执行线，线程被cpu调度并发执行。cpu运行调度的基本单元，共享进程的运行资源，虚拟内存，文件列表等。
协程：
  同样有执行上下文的保存和恢复，不存在并发执行，通过函数调用的形式进行执行线的切换，由用户程序负责



垃圾回收，边引用 边判别？

#### 文件系统：
  ```
  连续存储 链式存储
  索引
  ```
​	日志文件系统

#### io 模型:
  同步：
     阻塞  等待从磁盘->page cache, page cache->内存
     非阻塞 轮询page cache 中数据是否准备好，没有则直接返回。page cache -> 内存仍然是阻塞的
     1线程对应1 io
     io多路复用：1个线程轮询多个socket的情况
           select, poll: 将多个文件描述符从用户空间传入内核空间
                         内核轮询列表看是否有socket就绪，有则设置标记状态
                         将fd列表从内核空间传入用户空间，用户遍历列表对可读可写的socket的读写数据处理
                         差别: select用数组存储，poll用链表存储没有fd数量的限制
            epoll:
                由内核维护fd列表，红黑树，调用epoll_ctl添加删除fd
                epoll_wait 时，当有socket 可读可写时，通过回调添加到就绪链表，返回给用户空间
                边缘触发，水平触发：
                      当socket就绪，用户不做处理，第二次不通知（边缘触发），
                      所以一般配合非阻塞io处理，减少系统调用次数
   异步：

#### 线程安全
考虑资源是否有竞争，竞争激烈状况，以及加锁的代价。

线程安全：
   互斥访问（互斥锁）：互斥锁（队列排队等待），自旋锁（轮询尝试获取锁）
         互斥锁的代价：线程状态切换 运行态-> 阻塞态，阻塞态-> 就绪态
         自旋锁上锁代价：占有锁线程的运行时间
   乐观锁：假设竞争不激烈，不断重试

避免死锁：
    银行家算法

#### tcp
   流量控制
   拥塞控制

数据库三范式
    1范式 列的原子性，不可再分
    2范式 列依赖于主键，而不是依赖与主键的一部分
    3范式 不存在列对主键的传递依赖
    数据冗余，更新维护简单。


#### Mysql

- ACID特性

- 方便进行聚合范围查找，聚合、统计等操作

- 当数据规模变大时，查找性能变低



**存储**： 磁盘，B+树，支持索引查找，磁盘块读出

操作时间因素：**时间复杂度** + **数据规模**

当单表数据量很大时，查询性能很低  (减小表规模、将请求分发到多台服务器上 )

- 将历史数据归档到备份表
- 集群：主从复制，利用从数据库进行读写分离
- 缓存：缓存部分联表查询结果等
- 分库分表：减小数据规模

提高运算能力，集群，保持数据一致性，负载均衡


#### Redis:

-  基于内存的k-v数据库，数据结构，读写性能高
-  内存容量有限，对事务的支持差，不用于持久层

​    将mysql的数据 子集 缓存在redis中

#### redis mysql 数据一致性：不考虑进程执行中断

- 先更新缓存，再更新数据库
   a更新缓存 b更新缓存 ---> b更新数据库 a更新数据库
- 先更新数据库，再更新缓存
   a更新数据库 b更新数据库   --->  b更新缓存 a更新缓存

- 先删除缓存，再更新数据库
   a 删除缓存  ->  b读数据库更新缓存  ->  a 更新数据库
- 先更新数据库，再删除缓存
   b查找数据库 a更新数据库    --->  a删除缓存 b用旧值更新缓存 (这种发生概率比较低，因为更新数据库一般比查找耗时长，所以a删除缓存在后)

   问题: a 更新数据库，到删除缓存这段时间，b读到旧的缓存值(短暂不一致)

不能保证两个操作同时成功或失败

- 延时双删

   上述实践中大都可以保证相对一致性，若保证绝对一致性，要依靠事务保证操作更新同时成功或失败，出现问题则回滚，但**这与使用缓存提高性能的初衷相违背**，得不偿失。

缓存的命中率

cache aside: 旁路缓存模式
- 读：
​     缓存中有值，直接返回
​     缓存中无值，从数据库取值，更新缓存，返回
- 写
  更新数据库，删除缓存

read write through

write back

​

replication 备份
sharding 分片
